# CS106L 作业内容与要求说明

本文档详细解释了 CS106L（Stanford C++ 编程课程）2025秋季学期的所有作业内容与要求。

---

## 作业 0: 环境配置 (Assignment 0: Setup)

**截止日期**: 10月10日（星期五）晚上11:59

### 作业目标
配置整个学期所需的开发环境，确保能够编译和运行 C++ 文件，并使用自动评分系统。

### 主要任务

#### 第一部分：安装 Python
- 检查 Python 版本（需要 3.8 或更高版本）
- 如果没有安装，则安装 Python
- Linux/Mac 使用 `python3 --version` 检查
- Windows 使用 `python --version` 检查

#### 第二部分：设置 VSCode 和 C++ 编译器
- 安装 Visual Studio Code
- 安装 C/C++ 扩展
- 根据操作系统安装编译器：
  - **Mac**: 安装 Homebrew，然后安装 GCC (`g++-14`)
  - **Windows**: 安装 MinGW-w64 工具链
  - **Linux**: 安装 `g++-10` 或更高版本

#### 第三部分：通过 Git 克隆课程代码
- 确保已安装 Git
- 克隆课程仓库：`git clone https://github.com/cs106l/cs106l-assignments.git`
- 学习如何打开 VSCode 工作区
- 了解如何获取新的作业

#### 第四部分：测试配置
- 编译第一个 C++ 文件：`g++ -std=c++23 main.cpp -o main`
- 运行可执行文件：`./main`
- 验证自动评分器正常工作

### 提交要求
- 运行自动评分器确保所有测试通过
- 完成反馈表单

### 关键概念
- C++ 编译过程
- 开发环境配置
- 版本控制基础（Git）

---

## 作业 1: SimpleEnroll (课程注册系统)

**截止日期**: 10月17日（星期五）晚上11:59

### 作业目标
使用 ExploreCourses API 的数据，识别本年度提供和未提供的 CS 课程。练习流（streams）、初始化和引用的使用。

### 主要任务

#### 第零部分：阅读代码并填充 `Course` 结构体
- 理解 `Course` 结构体，用于表示从 ExploreCourses 提取的课程记录
- 填充结构体字段定义
- 注意流处理的数据类型
- 检查函数参数传递方式（是否需要引用传递）

#### 第一部分：实现 `parse_csv` 函数
- 从 `courses.csv` 文件读取课程数据
- CSV 文件包含三列：课程名称、学分数、学期
- 为每一行创建 `Course` 结构体
- **关键点**：
  - 使用流（stream）读取文件
  - 使用 `getline` 获取每一行
  - 使用提供的 `split` 函数分割 CSV 行
  - 跳过第一行（列标题）

#### 第二部分：实现 `write_courses_offered` 函数
- 将提供的课程（Quarter 字段不是 `"null"`）写入 `"student_output/courses_offered.csv"`
- **输出格式要求**：
  - 格式：`<Title>,<Number of Units>,<Quarter>`
  - 逗号之间无空格
  - 包含列标题行
- **重要**：从 `all_courses` 向量中删除已写入的课程
- 执行后，`all_courses` 应仅包含未提供的课程

#### 第三部分：实现 `write_courses_not_offered` 函数
- 将未提供的课程写入 `"student_output/courses_not_offered.csv"`
- 类似于第二部分，但更简单（因为已过滤掉提供的课程）

### 编译和运行
```bash
g++ -std=c++20 main.cpp -o main
./main
```

### 提交要求
- 文件：`main.cpp`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- C++ 流（streams）：`ifstream`、`ofstream`、`stringstream`
- CSV 文件处理
- 向量（vector）操作
- 引用传递 vs 值传递

---

## 作业 2: Marriage Pact (婚姻配对)

**截止日期**: 10月25日（星期六）晚上11:59

### 作业目标
练习使用 STL 容器（`std::set`/`std::unordered_set`、`std::queue`）和指针。

### 主要任务

#### 第零部分：设置
- 修改 `kYourName` 常量为你的全名

#### 第一部分：获取所有申请者 (`get_applicants`)
- 从 `students.txt` 文件解析所有学生姓名到集合中
- 每行包含一个学生的名字和姓氏
- 可以选择使用 `std::set`（有序）或 `std::unordered_set`（无序）
- **短答题 Q1**：比较有序集合和无序集合的权衡，并提供一个有效的哈希函数示例

#### 第二部分：查找匹配 (`find_matches` 和 `get_match`)

**`find_matches` 函数**：
- 从集合 `students` 中找出与参数 `name` 首字母相同的所有姓名
- 将指向这些姓名的指针放入新的 `std::queue` 中
- 提示：定义一个辅助函数来计算姓名的首字母
- 需要理解 `std::queue` 的操作

**`get_match` 函数**：
- 从所有可能匹配的队列中获取"唯一真正的匹配"
- 可以自由选择选择方法（随机或其他）
- 如果没有匹配，打印 `"NO MATCHES FOUND."`

**短答题 Q2**：
- 解释为什么在队列中保存指针而不是姓名本身
- 讨论如果原始集合超出作用域会发生什么

### 编译和运行
```bash
g++ -std=c++20 main.cpp -o main
./main
```

### 提交要求
- 文件：`main.cpp`、`short_answer.txt`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- STL 容器：`std::set`、`std::unordered_set`、`std::queue`
- 迭代器
- 指针基础
- 哈希函数

---

## 作业 3: Make a Class (创建类)

**截止日期**: 11月1日（星期六）晚上11:59

### 作业目标
创建自己的 C++ 类，理解类的声明与定义、构造函数、成员函数和 const 正确性。

### 主要任务

#### 第一部分：创建你的类
创建一个满足以下要求的类：

**必需要求**：
1. 具有接受一个或多个参数的自定义构造函数
2. 具有默认（无参数）构造函数（即构造函数重载）
3. 具有一个或多个私有成员字段（变量）
4. 具有一个或多个私有成员函数
5. 至少有一个公共 getter 函数用于其中一个私有字段
   - 例如：`int getData() const;`
   - getter 函数应标记为 `const`
6. 至少有一个公共 setter 函数用于其中一个私有字段
   - 例如：`void setData(int value);`

**文件组织**：
- `class.h` - 类声明（头文件）
- `class.cpp` - 类定义（实现文件）
- `sandbox.cpp` - 构造类实例

**可选挑战**：
- 创建类模板（使用 `template <typename T>`）
- 如果创建模板，必须从编译命令中移除 `class.cpp`

#### 第二部分：短答题
- **Q1**: 什么是 const 正确性，为什么它很重要？
- **Q2**: 你的类是否具有 const 正确性？你如何知道？

### 编译和运行
```bash
g++ -std=c++20 main.cpp class.cpp -o main
./main
```

### 提交要求
- 文件：`class.h`、`class.cpp`、`sandbox.cpp`、`short_answer.txt`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- 类的声明和定义
- 构造函数重载
- 访问修饰符（public、private）
- Getter 和 Setter
- Const 正确性
- 头文件和实现文件分离

---

## 作业 4: Ispell (拼写检查器)

**截止日期**: 11月8日（星期六）晚上11:59

### 作业目标
使用 STL 算法（`<algorithm>` 头文件）和 C++ ranges 库实现拼写检查器的核心逻辑。**不使用任何 for/while 循环**。

### 作业背景
实现类似 Unix Ispell 拼写检查器：
- 加载英语单词词典
- 使用 Damerau-Levenshtein 距离算法找出拼写错误
- 如果距离恰好为 1，则添加到建议列表

### 主要任务

#### 实现 `tokenize` 函数
将输入字符串分割成 `Token` 对象的集合。

**步骤**：
1. **识别所有空格字符的迭代器**
   - 使用提供的 `find_all` 函数
   - 传入 `std::isspace` 作为谓词

2. **生成连续空格字符之间的标记**
   - 使用 `std::transform`（重载 3）
   - 使用 lambda 函数构造 `Token`
   - 必须在 lambda 中按引用捕获 `source`
   - 使用 `std::inserter` 作为输出范围

3. **删除空标记**
   - 使用 `std::erase_if`
   - lambda 检查 `token.content.empty()`

#### 实现 `spellcheck` 函数
使用 ranges/views 库识别拼写错误。

**步骤**：
1. **跳过正确拼写的单词**
   - 使用 `std::ranges::views::filter`
   - lambda 检查词典中是否包含该词
   - 可使用命名空间别名：`namespace rv = std::ranges::views;`

2. **使用 Damerau-Levenshtein 找到编辑距离为 1 的单词**
   - 使用 `std::ranges::views::transform`
   - lambda 将 `Token` 转换为 `Misspelling`
   - 嵌套使用 `filter` 在词典中查找建议
   - 使用提供的 `levenshtein` 函数
   - 将视图实例化为集合

3. **删除没有建议的拼写错误**
   - 再次使用 `std::ranges::views::filter`
   - 将最终视图实例化为 `std::set<Misspelling>` 并返回

### 编译和运行
```bash
g++ -std=c++20 main.cpp spellcheck.cpp -o main
./main "hello wrld"
```

### 提交要求
- 文件：`spellcheck.cpp`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- STL 算法：`std::transform`、`std::erase_if`
- C++20 Ranges 和 Views
- Lambda 函数和捕获
- 迭代器操作
- 函数式编程范式
- 禁止使用循环的编程

---

## 作业 5: Treebook (社交媒体用户配置)

**截止日期**: 11月15日（星期六）晚上11:59

### 作业目标
实现运算符重载和特殊成员函数（SMF），处理动态内存管理。

### 作业背景
为虚构的 Stanford 社交媒体创业公司 Treebook 实现用户配置文件。`User` 类使用原始指针数组存储好友列表（类似 `std::vector` 的内部实现）。

### 主要任务

#### 第一部分：查看配置文件 (`operator<<`)
- 实现 `operator<<` 以将 `User` 打印到 `std::ostream`
- 在 `user.h` 中声明为友元函数，在 `user.cpp` 中实现
- 输出格式：`User(name=Alice, friends=[Bob, Charlie])`
- 不打印换行符

#### 第二部分：不友好的行为（特殊成员函数）
实现和删除特殊成员函数：

1. **实现析构函数** `~User()`
   - 释放动态分配的 `_friends` 数组

2. **实现拷贝构造函数** `User(const User& user)`
   - 深拷贝 `_friends` 数组
   - 拷贝 `_size`、`_capacity` 和 `_name`

3. **实现拷贝赋值运算符** `User& operator=(const User& user)`
   - 深拷贝 `_friends` 数组
   - 拷贝所有成员字段

4. **删除移动构造函数** `User(User&& user) = delete`

5. **删除移动赋值运算符** `User& operator=(User&& user) = delete`

#### 第三部分：始终在交友 (运算符重载)

**`operator+=`**：
- 将用户添加到另一个用户的好友列表
- 应该是对称的（双向添加）
- 签名：`User& operator+=(User& rhs)`
- 作为成员函数实现

**`operator<`**：
- 按姓名字母顺序比较用户
- 用于在 `std::set` 中存储用户
- 签名：`bool operator<(const User& rhs) const`
- 作为成员函数实现

### 编译和运行
```bash
g++ -std=c++20 main.cpp user.cpp -o main
./main
```

### 提交要求
- 文件：`user.h`、`user.cpp`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- 运算符重载
- 特殊成员函数（五大法则）
- 深拷贝 vs 浅拷贝
- 动态内存管理
- 友元函数
- RAII 原则

---

## 作业 6: Explore Courses (课程查找)

**截止日期**: 11月22日（星期六）晚上11:59

### 作业目标
练习使用 `std::optional` 和单子操作（monadic operations）。

### 主要任务

#### 第零部分：包含头文件
- 在 `main.cpp` 顶部包含 `<optional>`

#### 第一部分：编写 `find_course` 函数
- 接受 `course_title` 字符串参数
- 在 `CourseDatabase` 对象的私有 `courses` 成员中查找课程
- 返回类型应该是 `std::optional<Course>`（因为可能找不到课程）
- 将 `FillMeIn` 替换为正确的返回类型

#### 第二部分：修改 `main` 函数
**不使用任何条件语句**（如 `if` 语句）实现以下行为：

- 如果找到课程：
  ```
  Found course: <title>,<number_of_units>,<quarter>
  ```

- 如果未找到课程：
  ```
  Course not found.
  ```

**使用单子操作**：
需要使用 2 个单子函数，从以下三个中选择：

1. **`and_then`**：
   - 接受返回 `std::optional<U>` 的函数
   - 如果有值则应用函数，否则返回 `std::nullopt`

2. **`transform`**：
   - 接受返回 `U`（非 optional）的函数
   - 如果有值则应用函数并包装在 optional 中，否则返回 `std::nullopt`

3. **`or_else`**：
   - 接受返回 `std::optional<U>` 的无参数函数
   - 如果有值则返回它，否则调用函数

**示例结构**：
```cpp
std::string output = course
    ./* monadic function one */ (/* ... */)
    ./* monadic function two */ (/* ... */)
    .value();  // 或 .value_or(...)
```

### 编译和运行
```bash
g++ -std=c++23 main.cpp -o main
./main
```

### 提交要求
- 文件：`main.cpp`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- `std::optional`
- 单子操作（Monadic operations）
- 函数式编程
- Lambda 表达式
- 链式调用

---

## 作业 7: Unique Pointer (独占指针)

**截止日期**: 12月6日（星期六）晚上11:59

### 作业目标
实现自定义版本的 `unique_ptr`，理解 RAII、智能指针、模板、运算符重载和移动语义。

### 主要任务

#### 第一部分：实现 `unique_ptr`

**实现基本指针接口**：
- 私有部分（存储原始指针）
- 构造函数：`unique_ptr(T* ptr)`
- nullptr 构造函数：`unique_ptr(std::nullptr_t)`
- 解引用运算符：`T& operator*()` 和 `const T& operator*() const`
- 成员访问运算符：`T* operator->()` 和 `const T* operator->() const`
- 布尔转换运算符：`operator bool() const`

**实现 RAII（资源获取即初始化）**：
实现特殊成员函数：

1. **析构函数** `~unique_ptr()`
   - 释放指针的内存

2. **删除拷贝构造函数** `unique_ptr(const unique_ptr& other) = delete`

3. **删除拷贝赋值运算符** `unique_ptr& operator=(const unique_ptr& other) = delete`

4. **实现移动构造函数** `unique_ptr(unique_ptr&& other)`
   - 转移所有权
   - 将 `other` 的底层指针设为 `nullptr`

5. **实现移动赋值运算符** `unique_ptr& operator=(unique_ptr&& other)`
   - 转移所有权
   - 将 `other` 的底层指针设为 `nullptr`

**短答题**：
- **Q1**: 列出使用 RAII 管理内存而不是手动调用 `new` 和 `delete` 的一两个好处
- **Q2**: 解释为什么在移动构造函数中必须将 `other` 参数的底层指针设为 `nullptr`

#### 第二部分：使用 `unique_ptr`

**实现 `create_list` 函数**：
- 将 `std::vector<T>` 转换为 `unique_ptr<ListNode<T>>`
- 保持向量中元素的顺序
- 空向量返回 `nullptr`

**算法**：
1. 初始化 `cs106l::unique_ptr<ListNode<T>> head = nullptr`
2. **反向**遍历向量。对于每个元素：
   - 2a. 创建新的 `cs106l::unique_ptr<ListNode<T>> node`，值为向量中的元素
   - 2b. 设置 `node->next = std::move(head)`（使用移动语义）
   - 2c. 设置 `head = std::move(node)`
3. 返回 `head`

**短答题**：
- **Q3**: 这种通过 RAII 递归释放的方法对小列表效果很好，但对长列表可能有问题。为什么？（提示：递归函数调用栈的深度限制）
- **Q4**: 解释 `std::move` 在此上下文中的作用。为什么在这里使用 `std::move` 和移动语义是安全的？

### 编译和运行
```bash
g++ -std=c++20 main.cpp -o main
./main
```

### 提交要求
- 文件：`unique_ptr.h`、`main.cpp`、`short_answer.txt`
- 完成反馈表单
- 在 Paperless 上提交

### 关键概念
- RAII（资源获取即初始化）
- 智能指针
- 移动语义
- `std::move`
- 模板编程
- 特殊成员函数
- 运算符重载
- 内存管理

---

## 总结

本课程的 8 个作业涵盖了 C++ 编程的核心概念：

1. **作业 0**: 环境配置
2. **作业 1**: 流和文件 I/O
3. **作业 2**: STL 容器和指针
4. **作业 3**: 类的设计和实现
5. **作业 4**: STL 算法和 Ranges
6. **作业 5**: 运算符重载和特殊成员函数
7. **作业 6**: `std::optional` 和函数式编程
8. **作业 7**: 智能指针和 RAII

### 编译命令总结

| 作业 | 编译命令 |
|------|----------|
| 作业 0 | `g++ -std=c++23 main.cpp -o main` |
| 作业 1 | `g++ -std=c++20 main.cpp -o main` |
| 作业 2 | `g++ -std=c++20 main.cpp -o main` |
| 作业 3 | `g++ -std=c++20 main.cpp class.cpp -o main` |
| 作业 4 | `g++ -std=c++20 main.cpp spellcheck.cpp -o main` |
| 作业 5 | `g++ -std=c++20 main.cpp user.cpp -o main` |
| 作业 6 | `g++ -std=c++23 main.cpp -o main` |
| 作业 7 | `g++ -std=c++20 main.cpp -o main` |

### Windows 用户注意事项
所有作业在 Windows 上可能需要使用：
```bash
g++ -static-libstdc++ -std=c++20 main.cpp -o main
```
并且可执行文件可能名为 `main.exe`，运行时使用 `./main.exe`

### 提交流程
所有作业都需要：
1. 完成相应的反馈表单
2. 在 Paperless 网站提交代码文件
